#![allow(warnings)]
/* automatically generated by rust-bindgen 0.68.1 */

pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const EPERM: u32 = 1;
pub const ENOENT: u32 = 2;
pub const ESRCH: u32 = 3;
pub const EINTR: u32 = 4;
pub const EIO: u32 = 5;
pub const ENXIO: u32 = 6;
pub const E2BIG: u32 = 7;
pub const ENOEXEC: u32 = 8;
pub const EBADF: u32 = 9;
pub const ECHILD: u32 = 10;
pub const EDEADLK: u32 = 11;
pub const ENOMEM: u32 = 12;
pub const EACCES: u32 = 13;
pub const EFAULT: u32 = 14;
pub const ENOTBLK: u32 = 15;
pub const EBUSY: u32 = 16;
pub const EEXIST: u32 = 17;
pub const EXDEV: u32 = 18;
pub const ENODEV: u32 = 19;
pub const ENOTDIR: u32 = 20;
pub const EISDIR: u32 = 21;
pub const EINVAL: u32 = 22;
pub const ENFILE: u32 = 23;
pub const EMFILE: u32 = 24;
pub const ENOTTY: u32 = 25;
pub const ETXTBSY: u32 = 26;
pub const EFBIG: u32 = 27;
pub const ENOSPC: u32 = 28;
pub const ESPIPE: u32 = 29;
pub const EROFS: u32 = 30;
pub const EMLINK: u32 = 31;
pub const EPIPE: u32 = 32;
pub const EDOM: u32 = 33;
pub const ERANGE: u32 = 34;
pub const EAGAIN: u32 = 35;
pub const EWOULDBLOCK: u32 = 35;
pub const EINPROGRESS: u32 = 36;
pub const EALREADY: u32 = 37;
pub const ENOTSOCK: u32 = 38;
pub const EDESTADDRREQ: u32 = 39;
pub const EMSGSIZE: u32 = 40;
pub const EPROTOTYPE: u32 = 41;
pub const ENOPROTOOPT: u32 = 42;
pub const EPROTONOSUPPORT: u32 = 43;
pub const ESOCKTNOSUPPORT: u32 = 44;
pub const ENOTSUP: u32 = 45;
pub const EPFNOSUPPORT: u32 = 46;
pub const EAFNOSUPPORT: u32 = 47;
pub const EADDRINUSE: u32 = 48;
pub const EADDRNOTAVAIL: u32 = 49;
pub const ENETDOWN: u32 = 50;
pub const ENETUNREACH: u32 = 51;
pub const ENETRESET: u32 = 52;
pub const ECONNABORTED: u32 = 53;
pub const ECONNRESET: u32 = 54;
pub const ENOBUFS: u32 = 55;
pub const EISCONN: u32 = 56;
pub const ENOTCONN: u32 = 57;
pub const ESHUTDOWN: u32 = 58;
pub const ETOOMANYREFS: u32 = 59;
pub const ETIMEDOUT: u32 = 60;
pub const ECONNREFUSED: u32 = 61;
pub const ELOOP: u32 = 62;
pub const ENAMETOOLONG: u32 = 63;
pub const EHOSTDOWN: u32 = 64;
pub const EHOSTUNREACH: u32 = 65;
pub const ENOTEMPTY: u32 = 66;
pub const EPROCLIM: u32 = 67;
pub const EUSERS: u32 = 68;
pub const EDQUOT: u32 = 69;
pub const ESTALE: u32 = 70;
pub const EREMOTE: u32 = 71;
pub const EBADRPC: u32 = 72;
pub const ERPCMISMATCH: u32 = 73;
pub const EPROGUNAVAIL: u32 = 74;
pub const EPROGMISMATCH: u32 = 75;
pub const EPROCUNAVAIL: u32 = 76;
pub const ENOLCK: u32 = 77;
pub const ENOSYS: u32 = 78;
pub const EFTYPE: u32 = 79;
pub const EAUTH: u32 = 80;
pub const ENEEDAUTH: u32 = 81;
pub const EPWROFF: u32 = 82;
pub const EDEVERR: u32 = 83;
pub const EOVERFLOW: u32 = 84;
pub const EBADEXEC: u32 = 85;
pub const EBADARCH: u32 = 86;
pub const ESHLIBVERS: u32 = 87;
pub const EBADMACHO: u32 = 88;
pub const ECANCELED: u32 = 89;
pub const EIDRM: u32 = 90;
pub const ENOMSG: u32 = 91;
pub const EILSEQ: u32 = 92;
pub const ENOATTR: u32 = 93;
pub const EBADMSG: u32 = 94;
pub const EMULTIHOP: u32 = 95;
pub const ENODATA: u32 = 96;
pub const ENOLINK: u32 = 97;
pub const ENOSR: u32 = 98;
pub const ENOSTR: u32 = 99;
pub const EPROTO: u32 = 100;
pub const ETIME: u32 = 101;
pub const EOPNOTSUPP: u32 = 102;
pub const ENOPOLICY: u32 = 103;
pub const ENOTRECOVERABLE: u32 = 104;
pub const EOWNERDEAD: u32 = 105;
pub const EQFULL: u32 = 106;
pub const ELAST: u32 = 106;
pub const __WORDSIZE: u32 = 64;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const DAV1D_MAX_CDEF_STRENGTHS: u32 = 8;
pub const DAV1D_MAX_OPERATING_POINTS: u32 = 32;
pub const DAV1D_MAX_TILE_COLS: u32 = 64;
pub const DAV1D_MAX_TILE_ROWS: u32 = 64;
pub const DAV1D_MAX_SEGMENTS: u32 = 8;
pub const DAV1D_NUM_REF_FRAMES: u32 = 8;
pub const DAV1D_PRIMARY_REF_NONE: u32 = 7;
pub const DAV1D_REFS_PER_FRAME: u32 = 7;
pub const DAV1D_TOTAL_REFS_PER_FRAME: u32 = 8;
pub const DAV1D_PICTURE_ALIGNMENT: u32 = 64;
pub const DAV1D_API_VERSION_MAJOR: u32 = 7;
pub const DAV1D_API_VERSION_MINOR: u32 = 0;
pub const DAV1D_API_VERSION_PATCH: u32 = 0;
pub const DAV1D_MAX_THREADS: u32 = 256;
pub const DAV1D_MAX_FRAME_DELAY: u32 = 256;
pub type errno_t = ::std::os::raw::c_int;
extern "C" {
    pub fn __error() -> *mut ::std::os::raw::c_int;
}
pub type __gnuc_va_list = __builtin_va_list;
pub type va_list = __builtin_va_list;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
#[doc = " A reference-counted object wrapper for a user-configurable pointer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dUserData {
    #[doc = "< data pointer"]
    pub data: *const u8,
    #[doc = "< allocation origin"]
    pub ref_: *mut Dav1dRef,
}
#[test]
fn bindgen_test_layout_Dav1dUserData() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dUserData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dUserData>(),
        16usize,
        concat!("Size of: ", stringify!(Dav1dUserData))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dUserData>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dUserData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dUserData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dUserData),
            "::",
            stringify!(ref_)
        )
    );
}
#[doc = " Input packet metadata which are copied from the input data used to\n decode each image into the matching structure of the output image\n returned back to the user. Since these are metadata fields, they\n can be used for other purposes than the documented ones, they will\n still be passed from input data to output picture without being\n used internally."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dDataProps {
    #[doc = "< container timestamp of input data, INT64_MIN if unknown (default)"]
    pub timestamp: i64,
    #[doc = "< container duration of input data, 0 if unknown (default)"]
    pub duration: i64,
    #[doc = "< stream offset of input data, -1 if unknown (default)"]
    pub offset: i64,
    #[doc = "< packet size, default Dav1dData.sz"]
    pub size: usize,
    #[doc = "< user-configurable data, default NULL members"]
    pub user_data: Dav1dUserData,
}
#[test]
fn bindgen_test_layout_Dav1dDataProps() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dDataProps> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dDataProps>(),
        48usize,
        concat!("Size of: ", stringify!(Dav1dDataProps))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dDataProps>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dDataProps))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dDataProps),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).duration) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dDataProps),
            "::",
            stringify!(duration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).offset) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dDataProps),
            "::",
            stringify!(offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).size) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dDataProps),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).user_data) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dDataProps),
            "::",
            stringify!(user_data)
        )
    );
}
extern "C" {
    #[doc = " Release reference to a Dav1dDataProps."]
    pub fn dav1d_data_props_unref(props: *mut Dav1dDataProps);
}
pub const Dav1dObuType_DAV1D_OBU_SEQ_HDR: Dav1dObuType = 1;
pub const Dav1dObuType_DAV1D_OBU_TD: Dav1dObuType = 2;
pub const Dav1dObuType_DAV1D_OBU_FRAME_HDR: Dav1dObuType = 3;
pub const Dav1dObuType_DAV1D_OBU_TILE_GRP: Dav1dObuType = 4;
pub const Dav1dObuType_DAV1D_OBU_METADATA: Dav1dObuType = 5;
pub const Dav1dObuType_DAV1D_OBU_FRAME: Dav1dObuType = 6;
pub const Dav1dObuType_DAV1D_OBU_REDUNDANT_FRAME_HDR: Dav1dObuType = 7;
pub const Dav1dObuType_DAV1D_OBU_PADDING: Dav1dObuType = 15;
pub type Dav1dObuType = ::std::os::raw::c_uint;
pub const Dav1dTxfmMode_DAV1D_TX_4X4_ONLY: Dav1dTxfmMode = 0;
pub const Dav1dTxfmMode_DAV1D_TX_LARGEST: Dav1dTxfmMode = 1;
pub const Dav1dTxfmMode_DAV1D_TX_SWITCHABLE: Dav1dTxfmMode = 2;
pub const Dav1dTxfmMode_DAV1D_N_TX_MODES: Dav1dTxfmMode = 3;
pub type Dav1dTxfmMode = ::std::os::raw::c_uint;
pub const Dav1dFilterMode_DAV1D_FILTER_8TAP_REGULAR: Dav1dFilterMode = 0;
pub const Dav1dFilterMode_DAV1D_FILTER_8TAP_SMOOTH: Dav1dFilterMode = 1;
pub const Dav1dFilterMode_DAV1D_FILTER_8TAP_SHARP: Dav1dFilterMode = 2;
pub const Dav1dFilterMode_DAV1D_N_SWITCHABLE_FILTERS: Dav1dFilterMode = 3;
pub const Dav1dFilterMode_DAV1D_FILTER_BILINEAR: Dav1dFilterMode = 3;
pub const Dav1dFilterMode_DAV1D_N_FILTERS: Dav1dFilterMode = 4;
pub const Dav1dFilterMode_DAV1D_FILTER_SWITCHABLE: Dav1dFilterMode = 4;
pub type Dav1dFilterMode = ::std::os::raw::c_uint;
pub const Dav1dAdaptiveBoolean_DAV1D_OFF: Dav1dAdaptiveBoolean = 0;
pub const Dav1dAdaptiveBoolean_DAV1D_ON: Dav1dAdaptiveBoolean = 1;
pub const Dav1dAdaptiveBoolean_DAV1D_ADAPTIVE: Dav1dAdaptiveBoolean = 2;
pub type Dav1dAdaptiveBoolean = ::std::os::raw::c_uint;
pub const Dav1dRestorationType_DAV1D_RESTORATION_NONE: Dav1dRestorationType = 0;
pub const Dav1dRestorationType_DAV1D_RESTORATION_SWITCHABLE: Dav1dRestorationType = 1;
pub const Dav1dRestorationType_DAV1D_RESTORATION_WIENER: Dav1dRestorationType = 2;
pub const Dav1dRestorationType_DAV1D_RESTORATION_SGRPROJ: Dav1dRestorationType = 3;
pub type Dav1dRestorationType = ::std::os::raw::c_uint;
pub const Dav1dWarpedMotionType_DAV1D_WM_TYPE_IDENTITY: Dav1dWarpedMotionType = 0;
pub const Dav1dWarpedMotionType_DAV1D_WM_TYPE_TRANSLATION: Dav1dWarpedMotionType = 1;
pub const Dav1dWarpedMotionType_DAV1D_WM_TYPE_ROT_ZOOM: Dav1dWarpedMotionType = 2;
pub const Dav1dWarpedMotionType_DAV1D_WM_TYPE_AFFINE: Dav1dWarpedMotionType = 3;
pub type Dav1dWarpedMotionType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dav1dWarpedMotionParams {
    pub type_: Dav1dWarpedMotionType,
    pub matrix: [i32; 6usize],
    pub u: Dav1dWarpedMotionParams__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union Dav1dWarpedMotionParams__bindgen_ty_1 {
    pub p: Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1,
    pub abcd: [i16; 4usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1 {
    pub alpha: i16,
    pub beta: i16,
    pub gamma: i16,
    pub delta: i16,
}
#[test]
fn bindgen_test_layout_Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alpha) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).beta) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(beta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gamma) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(gamma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(delta)
        )
    );
}
#[test]
fn bindgen_test_layout_Dav1dWarpedMotionParams__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dWarpedMotionParams__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dWarpedMotionParams__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dWarpedMotionParams__bindgen_ty_1>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).abcd) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams__bindgen_ty_1),
            "::",
            stringify!(abcd)
        )
    );
}
#[test]
fn bindgen_test_layout_Dav1dWarpedMotionParams() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dWarpedMotionParams> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dWarpedMotionParams>(),
        36usize,
        concat!("Size of: ", stringify!(Dav1dWarpedMotionParams))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dWarpedMotionParams>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dWarpedMotionParams))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).matrix) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams),
            "::",
            stringify!(matrix)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).u) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dWarpedMotionParams),
            "::",
            stringify!(u)
        )
    );
}
#[doc = "< monochrome"]
pub const Dav1dPixelLayout_DAV1D_PIXEL_LAYOUT_I400: Dav1dPixelLayout = 0;
#[doc = "< 4:2:0 planar"]
pub const Dav1dPixelLayout_DAV1D_PIXEL_LAYOUT_I420: Dav1dPixelLayout = 1;
#[doc = "< 4:2:2 planar"]
pub const Dav1dPixelLayout_DAV1D_PIXEL_LAYOUT_I422: Dav1dPixelLayout = 2;
#[doc = "< 4:4:4 planar"]
pub const Dav1dPixelLayout_DAV1D_PIXEL_LAYOUT_I444: Dav1dPixelLayout = 3;
pub type Dav1dPixelLayout = ::std::os::raw::c_uint;
#[doc = "< Key Intra frame"]
pub const Dav1dFrameType_DAV1D_FRAME_TYPE_KEY: Dav1dFrameType = 0;
#[doc = "< Inter frame"]
pub const Dav1dFrameType_DAV1D_FRAME_TYPE_INTER: Dav1dFrameType = 1;
#[doc = "< Non key Intra frame"]
pub const Dav1dFrameType_DAV1D_FRAME_TYPE_INTRA: Dav1dFrameType = 2;
#[doc = "< Switch Inter frame"]
pub const Dav1dFrameType_DAV1D_FRAME_TYPE_SWITCH: Dav1dFrameType = 3;
pub type Dav1dFrameType = ::std::os::raw::c_uint;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_BT709: Dav1dColorPrimaries = 1;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_UNKNOWN: Dav1dColorPrimaries = 2;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_BT470M: Dav1dColorPrimaries = 4;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_BT470BG: Dav1dColorPrimaries = 5;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_BT601: Dav1dColorPrimaries = 6;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_SMPTE240: Dav1dColorPrimaries = 7;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_FILM: Dav1dColorPrimaries = 8;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_BT2020: Dav1dColorPrimaries = 9;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_XYZ: Dav1dColorPrimaries = 10;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_SMPTE431: Dav1dColorPrimaries = 11;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_SMPTE432: Dav1dColorPrimaries = 12;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_EBU3213: Dav1dColorPrimaries = 22;
pub const Dav1dColorPrimaries_DAV1D_COLOR_PRI_RESERVED: Dav1dColorPrimaries = 255;
pub type Dav1dColorPrimaries = ::std::os::raw::c_uint;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT709: Dav1dTransferCharacteristics = 1;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_UNKNOWN: Dav1dTransferCharacteristics = 2;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT470M: Dav1dTransferCharacteristics = 4;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT470BG: Dav1dTransferCharacteristics = 5;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT601: Dav1dTransferCharacteristics = 6;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_SMPTE240: Dav1dTransferCharacteristics = 7;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_LINEAR: Dav1dTransferCharacteristics = 8;
#[doc = "< logarithmic (100:1 range)"]
pub const Dav1dTransferCharacteristics_DAV1D_TRC_LOG100: Dav1dTransferCharacteristics = 9;
#[doc = "< lograithmic (100*sqrt(10):1 range)"]
pub const Dav1dTransferCharacteristics_DAV1D_TRC_LOG100_SQRT10: Dav1dTransferCharacteristics = 10;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_IEC61966: Dav1dTransferCharacteristics = 11;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT1361: Dav1dTransferCharacteristics = 12;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_SRGB: Dav1dTransferCharacteristics = 13;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT2020_10BIT: Dav1dTransferCharacteristics = 14;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_BT2020_12BIT: Dav1dTransferCharacteristics = 15;
#[doc = "< PQ"]
pub const Dav1dTransferCharacteristics_DAV1D_TRC_SMPTE2084: Dav1dTransferCharacteristics = 16;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_SMPTE428: Dav1dTransferCharacteristics = 17;
#[doc = "< hybrid log/gamma (BT.2100 / ARIB STD-B67)"]
pub const Dav1dTransferCharacteristics_DAV1D_TRC_HLG: Dav1dTransferCharacteristics = 18;
pub const Dav1dTransferCharacteristics_DAV1D_TRC_RESERVED: Dav1dTransferCharacteristics = 255;
pub type Dav1dTransferCharacteristics = ::std::os::raw::c_uint;
pub const Dav1dMatrixCoefficients_DAV1D_MC_IDENTITY: Dav1dMatrixCoefficients = 0;
pub const Dav1dMatrixCoefficients_DAV1D_MC_BT709: Dav1dMatrixCoefficients = 1;
pub const Dav1dMatrixCoefficients_DAV1D_MC_UNKNOWN: Dav1dMatrixCoefficients = 2;
pub const Dav1dMatrixCoefficients_DAV1D_MC_FCC: Dav1dMatrixCoefficients = 4;
pub const Dav1dMatrixCoefficients_DAV1D_MC_BT470BG: Dav1dMatrixCoefficients = 5;
pub const Dav1dMatrixCoefficients_DAV1D_MC_BT601: Dav1dMatrixCoefficients = 6;
pub const Dav1dMatrixCoefficients_DAV1D_MC_SMPTE240: Dav1dMatrixCoefficients = 7;
pub const Dav1dMatrixCoefficients_DAV1D_MC_SMPTE_YCGCO: Dav1dMatrixCoefficients = 8;
pub const Dav1dMatrixCoefficients_DAV1D_MC_BT2020_NCL: Dav1dMatrixCoefficients = 9;
pub const Dav1dMatrixCoefficients_DAV1D_MC_BT2020_CL: Dav1dMatrixCoefficients = 10;
pub const Dav1dMatrixCoefficients_DAV1D_MC_SMPTE2085: Dav1dMatrixCoefficients = 11;
#[doc = "< Chromaticity-derived"]
pub const Dav1dMatrixCoefficients_DAV1D_MC_CHROMAT_NCL: Dav1dMatrixCoefficients = 12;
pub const Dav1dMatrixCoefficients_DAV1D_MC_CHROMAT_CL: Dav1dMatrixCoefficients = 13;
pub const Dav1dMatrixCoefficients_DAV1D_MC_ICTCP: Dav1dMatrixCoefficients = 14;
pub const Dav1dMatrixCoefficients_DAV1D_MC_RESERVED: Dav1dMatrixCoefficients = 255;
pub type Dav1dMatrixCoefficients = ::std::os::raw::c_uint;
pub const Dav1dChromaSamplePosition_DAV1D_CHR_UNKNOWN: Dav1dChromaSamplePosition = 0;
#[doc = "< Horizontally co-located with luma(0, 0)\n< sample, between two vertical samples"]
pub const Dav1dChromaSamplePosition_DAV1D_CHR_VERTICAL: Dav1dChromaSamplePosition = 1;
#[doc = "< Co-located with luma(0, 0) sample"]
pub const Dav1dChromaSamplePosition_DAV1D_CHR_COLOCATED: Dav1dChromaSamplePosition = 2;
pub type Dav1dChromaSamplePosition = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dContentLightLevel {
    pub max_content_light_level: ::std::os::raw::c_int,
    pub max_frame_average_light_level: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dContentLightLevel() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dContentLightLevel> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dContentLightLevel>(),
        8usize,
        concat!("Size of: ", stringify!(Dav1dContentLightLevel))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dContentLightLevel>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dContentLightLevel))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_content_light_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dContentLightLevel),
            "::",
            stringify!(max_content_light_level)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).max_frame_average_light_level) as usize - ptr as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dContentLightLevel),
            "::",
            stringify!(max_frame_average_light_level)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dMasteringDisplay {
    pub primaries: [[u16; 2usize]; 3usize],
    pub white_point: [u16; 2usize],
    pub max_luminance: u32,
    pub min_luminance: u32,
}
#[test]
fn bindgen_test_layout_Dav1dMasteringDisplay() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dMasteringDisplay> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dMasteringDisplay>(),
        24usize,
        concat!("Size of: ", stringify!(Dav1dMasteringDisplay))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dMasteringDisplay>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dMasteringDisplay))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primaries) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dMasteringDisplay),
            "::",
            stringify!(primaries)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).white_point) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dMasteringDisplay),
            "::",
            stringify!(white_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_luminance) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dMasteringDisplay),
            "::",
            stringify!(max_luminance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_luminance) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dMasteringDisplay),
            "::",
            stringify!(min_luminance)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dITUTT35 {
    pub country_code: u8,
    pub country_code_extension_byte: u8,
    pub payload_size: usize,
    pub payload: *mut u8,
}
#[test]
fn bindgen_test_layout_Dav1dITUTT35() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dITUTT35> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dITUTT35>(),
        24usize,
        concat!("Size of: ", stringify!(Dav1dITUTT35))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dITUTT35>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dITUTT35))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).country_code) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dITUTT35),
            "::",
            stringify!(country_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).country_code_extension_byte) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dITUTT35),
            "::",
            stringify!(country_code_extension_byte)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dITUTT35),
            "::",
            stringify!(payload_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).payload) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dITUTT35),
            "::",
            stringify!(payload)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSequenceHeader {
    #[doc = " Stream profile, 0 for 8-10 bits/component 4:2:0 or monochrome;\n 1 for 8-10 bits/component 4:4:4; 2 for 4:2:2 at any bits/component,\n or 12 bits/component at any chroma subsampling."]
    pub profile: ::std::os::raw::c_int,
    #[doc = " Maximum dimensions for this stream. In non-scalable streams, these\n are often the actual dimensions of the stream, although that is not\n a normative requirement."]
    pub max_width: ::std::os::raw::c_int,
    #[doc = " Maximum dimensions for this stream. In non-scalable streams, these\n are often the actual dimensions of the stream, although that is not\n a normative requirement."]
    pub max_height: ::std::os::raw::c_int,
    #[doc = "< format of the picture"]
    pub layout: Dav1dPixelLayout,
    #[doc = "< color primaries (av1)"]
    pub pri: Dav1dColorPrimaries,
    #[doc = "< transfer characteristics (av1)"]
    pub trc: Dav1dTransferCharacteristics,
    #[doc = "< matrix coefficients (av1)"]
    pub mtrx: Dav1dMatrixCoefficients,
    #[doc = "< chroma sample position (av1)"]
    pub chr: Dav1dChromaSamplePosition,
    #[doc = " 0, 1 and 2 mean 8, 10 or 12 bits/component, respectively. This is not\n exactly the same as 'hbd' from the spec; the spec's hbd distinguishes\n between 8 (0) and 10-12 (1) bits/component, and another element\n (twelve_bit) to distinguish between 10 and 12 bits/component. To get\n the spec's hbd, use !!our_hbd, and to get twelve_bit, use hbd == 2."]
    pub hbd: ::std::os::raw::c_int,
    #[doc = " Pixel data uses JPEG pixel range ([0,255] for 8bits) instead of\n MPEG pixel range ([16,235] for 8bits luma, [16,240] for 8bits chroma)."]
    pub color_range: ::std::os::raw::c_int,
    pub num_operating_points: ::std::os::raw::c_int,
    pub operating_points: [Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint; 32usize],
    pub still_picture: ::std::os::raw::c_int,
    pub reduced_still_picture_header: ::std::os::raw::c_int,
    pub timing_info_present: ::std::os::raw::c_int,
    pub num_units_in_tick: ::std::os::raw::c_int,
    pub time_scale: ::std::os::raw::c_int,
    pub equal_picture_interval: ::std::os::raw::c_int,
    pub num_ticks_per_picture: ::std::os::raw::c_uint,
    pub decoder_model_info_present: ::std::os::raw::c_int,
    pub encoder_decoder_buffer_delay_length: ::std::os::raw::c_int,
    pub num_units_in_decoding_tick: ::std::os::raw::c_int,
    pub buffer_removal_delay_length: ::std::os::raw::c_int,
    pub frame_presentation_delay_length: ::std::os::raw::c_int,
    pub display_model_info_present: ::std::os::raw::c_int,
    pub width_n_bits: ::std::os::raw::c_int,
    pub height_n_bits: ::std::os::raw::c_int,
    pub frame_id_numbers_present: ::std::os::raw::c_int,
    pub delta_frame_id_n_bits: ::std::os::raw::c_int,
    pub frame_id_n_bits: ::std::os::raw::c_int,
    pub sb128: ::std::os::raw::c_int,
    pub filter_intra: ::std::os::raw::c_int,
    pub intra_edge_filter: ::std::os::raw::c_int,
    pub inter_intra: ::std::os::raw::c_int,
    pub masked_compound: ::std::os::raw::c_int,
    pub warped_motion: ::std::os::raw::c_int,
    pub dual_filter: ::std::os::raw::c_int,
    pub order_hint: ::std::os::raw::c_int,
    pub jnt_comp: ::std::os::raw::c_int,
    pub ref_frame_mvs: ::std::os::raw::c_int,
    pub screen_content_tools: Dav1dAdaptiveBoolean,
    pub force_integer_mv: Dav1dAdaptiveBoolean,
    pub order_hint_n_bits: ::std::os::raw::c_int,
    pub super_res: ::std::os::raw::c_int,
    pub cdef: ::std::os::raw::c_int,
    pub restoration: ::std::os::raw::c_int,
    pub ss_hor: ::std::os::raw::c_int,
    pub ss_ver: ::std::os::raw::c_int,
    pub monochrome: ::std::os::raw::c_int,
    pub color_description_present: ::std::os::raw::c_int,
    pub separate_uv_delta_q: ::std::os::raw::c_int,
    pub film_grain_present: ::std::os::raw::c_int,
    pub operating_parameter_info:
        [Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo; 32usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint {
    pub major_level: ::std::os::raw::c_int,
    pub minor_level: ::std::os::raw::c_int,
    pub initial_display_delay: ::std::os::raw::c_int,
    pub idc: ::std::os::raw::c_int,
    pub tier: ::std::os::raw::c_int,
    pub decoder_model_param_present: ::std::os::raw::c_int,
    pub display_model_param_present: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint>(),
        28usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major_level) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(major_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor_level) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(minor_level)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).initial_display_delay) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(initial_display_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).idc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(idc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tier) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(tier)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder_model_param_present) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(decoder_model_param_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_model_param_present) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingPoint),
            "::",
            stringify!(display_model_param_present)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo {
    pub decoder_buffer_delay: ::std::os::raw::c_int,
    pub encoder_buffer_delay: ::std::os::raw::c_int,
    pub low_delay_mode: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo() {
    const UNINIT: ::std::mem::MaybeUninit<
        Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo,
    > = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder_buffer_delay) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo),
            "::",
            stringify!(decoder_buffer_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).encoder_buffer_delay) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo),
            "::",
            stringify!(encoder_buffer_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).low_delay_mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader_Dav1dSequenceHeaderOperatingParameterInfo),
            "::",
            stringify!(low_delay_mode)
        )
    );
}
#[test]
fn bindgen_test_layout_Dav1dSequenceHeader() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dSequenceHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSequenceHeader>(),
        1484usize,
        concat!("Size of: ", stringify!(Dav1dSequenceHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSequenceHeader>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dSequenceHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_width) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(max_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_height) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(max_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pri) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(pri)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).trc) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(trc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mtrx) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(mtrx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chr) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(chr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hbd) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(hbd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_range) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(color_range)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_operating_points) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(num_operating_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_points) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(operating_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).still_picture) as usize - ptr as usize },
        940usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(still_picture)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).reduced_still_picture_header) as usize - ptr as usize
        },
        944usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(reduced_still_picture_header)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timing_info_present) as usize - ptr as usize },
        948usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(timing_info_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_units_in_tick) as usize - ptr as usize },
        952usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(num_units_in_tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).time_scale) as usize - ptr as usize },
        956usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(time_scale)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).equal_picture_interval) as usize - ptr as usize },
        960usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(equal_picture_interval)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_ticks_per_picture) as usize - ptr as usize },
        964usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(num_ticks_per_picture)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decoder_model_info_present) as usize - ptr as usize },
        968usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(decoder_model_info_present)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).encoder_decoder_buffer_delay_length) as usize - ptr as usize
        },
        972usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(encoder_decoder_buffer_delay_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_units_in_decoding_tick) as usize - ptr as usize },
        976usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(num_units_in_decoding_tick)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_removal_delay_length) as usize - ptr as usize },
        980usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(buffer_removal_delay_length)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).frame_presentation_delay_length) as usize - ptr as usize
        },
        984usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(frame_presentation_delay_length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).display_model_info_present) as usize - ptr as usize },
        988usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(display_model_info_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_n_bits) as usize - ptr as usize },
        992usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(width_n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height_n_bits) as usize - ptr as usize },
        996usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(height_n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_id_numbers_present) as usize - ptr as usize },
        1000usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(frame_id_numbers_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_frame_id_n_bits) as usize - ptr as usize },
        1004usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(delta_frame_id_n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_id_n_bits) as usize - ptr as usize },
        1008usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(frame_id_n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sb128) as usize - ptr as usize },
        1012usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(sb128)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).filter_intra) as usize - ptr as usize },
        1016usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(filter_intra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).intra_edge_filter) as usize - ptr as usize },
        1020usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(intra_edge_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inter_intra) as usize - ptr as usize },
        1024usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(inter_intra)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).masked_compound) as usize - ptr as usize },
        1028usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(masked_compound)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warped_motion) as usize - ptr as usize },
        1032usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(warped_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dual_filter) as usize - ptr as usize },
        1036usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(dual_filter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order_hint) as usize - ptr as usize },
        1040usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(order_hint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).jnt_comp) as usize - ptr as usize },
        1044usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(jnt_comp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_frame_mvs) as usize - ptr as usize },
        1048usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(ref_frame_mvs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).screen_content_tools) as usize - ptr as usize },
        1052usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(screen_content_tools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_integer_mv) as usize - ptr as usize },
        1056usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(force_integer_mv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).order_hint_n_bits) as usize - ptr as usize },
        1060usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(order_hint_n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_res) as usize - ptr as usize },
        1064usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(super_res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdef) as usize - ptr as usize },
        1068usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(cdef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restoration) as usize - ptr as usize },
        1072usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(restoration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_hor) as usize - ptr as usize },
        1076usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(ss_hor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_ver) as usize - ptr as usize },
        1080usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(ss_ver)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).monochrome) as usize - ptr as usize },
        1084usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(monochrome)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).color_description_present) as usize - ptr as usize },
        1088usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(color_description_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).separate_uv_delta_q) as usize - ptr as usize },
        1092usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(separate_uv_delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).film_grain_present) as usize - ptr as usize },
        1096usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(film_grain_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_parameter_info) as usize - ptr as usize },
        1100usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSequenceHeader),
            "::",
            stringify!(operating_parameter_info)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSegmentationData {
    pub delta_q: ::std::os::raw::c_int,
    pub delta_lf_y_v: ::std::os::raw::c_int,
    pub delta_lf_y_h: ::std::os::raw::c_int,
    pub delta_lf_u: ::std::os::raw::c_int,
    pub delta_lf_v: ::std::os::raw::c_int,
    pub ref_: ::std::os::raw::c_int,
    pub skip: ::std::os::raw::c_int,
    pub globalmv: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dSegmentationData() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dSegmentationData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSegmentationData>(),
        32usize,
        concat!("Size of: ", stringify!(Dav1dSegmentationData))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSegmentationData>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dSegmentationData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(delta_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_lf_y_v) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(delta_lf_y_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_lf_y_h) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(delta_lf_y_h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_lf_u) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(delta_lf_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta_lf_v) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(delta_lf_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(skip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).globalmv) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationData),
            "::",
            stringify!(globalmv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSegmentationDataSet {
    pub d: [Dav1dSegmentationData; 8usize],
    pub preskip: ::std::os::raw::c_int,
    pub last_active_segid: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dSegmentationDataSet() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dSegmentationDataSet> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSegmentationDataSet>(),
        264usize,
        concat!("Size of: ", stringify!(Dav1dSegmentationDataSet))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSegmentationDataSet>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dSegmentationDataSet))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).d) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationDataSet),
            "::",
            stringify!(d)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).preskip) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationDataSet),
            "::",
            stringify!(preskip)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).last_active_segid) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSegmentationDataSet),
            "::",
            stringify!(last_active_segid)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dLoopfilterModeRefDeltas {
    pub mode_delta: [::std::os::raw::c_int; 2usize],
    pub ref_delta: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_Dav1dLoopfilterModeRefDeltas() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dLoopfilterModeRefDeltas> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dLoopfilterModeRefDeltas>(),
        40usize,
        concat!("Size of: ", stringify!(Dav1dLoopfilterModeRefDeltas))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dLoopfilterModeRefDeltas>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dLoopfilterModeRefDeltas))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_delta) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dLoopfilterModeRefDeltas),
            "::",
            stringify!(mode_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_delta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dLoopfilterModeRefDeltas),
            "::",
            stringify!(ref_delta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFilmGrainData {
    pub seed: ::std::os::raw::c_uint,
    pub num_y_points: ::std::os::raw::c_int,
    pub y_points: [[u8; 2usize]; 14usize],
    pub chroma_scaling_from_luma: ::std::os::raw::c_int,
    pub num_uv_points: [::std::os::raw::c_int; 2usize],
    pub uv_points: [[[u8; 2usize]; 10usize]; 2usize],
    pub scaling_shift: ::std::os::raw::c_int,
    pub ar_coeff_lag: ::std::os::raw::c_int,
    pub ar_coeffs_y: [i8; 24usize],
    pub ar_coeffs_uv: [[i8; 28usize]; 2usize],
    pub ar_coeff_shift: u64,
    pub grain_scale_shift: ::std::os::raw::c_int,
    pub uv_mult: [::std::os::raw::c_int; 2usize],
    pub uv_luma_mult: [::std::os::raw::c_int; 2usize],
    pub uv_offset: [::std::os::raw::c_int; 2usize],
    pub overlap_flag: ::std::os::raw::c_int,
    pub clip_to_restricted_range: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFilmGrainData() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFilmGrainData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFilmGrainData>(),
        224usize,
        concat!("Size of: ", stringify!(Dav1dFilmGrainData))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFilmGrainData>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dFilmGrainData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seed) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(seed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_y_points) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(num_y_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_points) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(y_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).chroma_scaling_from_luma) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(chroma_scaling_from_luma)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num_uv_points) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(num_uv_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_points) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(uv_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scaling_shift) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(scaling_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeff_lag) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(ar_coeff_lag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_y) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(ar_coeffs_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeffs_uv) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(ar_coeffs_uv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ar_coeff_shift) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(ar_coeff_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).grain_scale_shift) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(grain_scale_shift)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_mult) as usize - ptr as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(uv_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_luma_mult) as usize - ptr as usize },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(uv_luma_mult)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_offset) as usize - ptr as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(uv_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).overlap_flag) as usize - ptr as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(overlap_flag)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).clip_to_restricted_range) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFilmGrainData),
            "::",
            stringify!(clip_to_restricted_range)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dav1dFrameHeader {
    #[doc = "< film grain parameters"]
    pub film_grain: Dav1dFrameHeader__bindgen_ty_1,
    #[doc = "< type of the picture"]
    pub frame_type: Dav1dFrameType,
    pub width: [::std::os::raw::c_int; 2usize],
    pub height: ::std::os::raw::c_int,
    #[doc = "< frame number"]
    pub frame_offset: ::std::os::raw::c_int,
    #[doc = "< temporal id of the frame for SVC"]
    pub temporal_id: ::std::os::raw::c_int,
    #[doc = "< spatial id of the frame for SVC"]
    pub spatial_id: ::std::os::raw::c_int,
    pub show_existing_frame: ::std::os::raw::c_int,
    pub existing_frame_idx: ::std::os::raw::c_int,
    pub frame_id: ::std::os::raw::c_int,
    pub frame_presentation_delay: ::std::os::raw::c_int,
    pub show_frame: ::std::os::raw::c_int,
    pub showable_frame: ::std::os::raw::c_int,
    pub error_resilient_mode: ::std::os::raw::c_int,
    pub disable_cdf_update: ::std::os::raw::c_int,
    pub allow_screen_content_tools: ::std::os::raw::c_int,
    pub force_integer_mv: ::std::os::raw::c_int,
    pub frame_size_override: ::std::os::raw::c_int,
    pub primary_ref_frame: ::std::os::raw::c_int,
    pub buffer_removal_time_present: ::std::os::raw::c_int,
    pub operating_points: [Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint; 32usize],
    pub refresh_frame_flags: ::std::os::raw::c_int,
    pub render_width: ::std::os::raw::c_int,
    pub render_height: ::std::os::raw::c_int,
    pub super_res: Dav1dFrameHeader__bindgen_ty_2,
    pub have_render_size: ::std::os::raw::c_int,
    pub allow_intrabc: ::std::os::raw::c_int,
    pub frame_ref_short_signaling: ::std::os::raw::c_int,
    pub refidx: [::std::os::raw::c_int; 7usize],
    pub hp: ::std::os::raw::c_int,
    pub subpel_filter_mode: Dav1dFilterMode,
    pub switchable_motion_mode: ::std::os::raw::c_int,
    pub use_ref_frame_mvs: ::std::os::raw::c_int,
    pub refresh_context: ::std::os::raw::c_int,
    pub tiling: Dav1dFrameHeader__bindgen_ty_3,
    pub quant: Dav1dFrameHeader__bindgen_ty_4,
    pub segmentation: Dav1dFrameHeader__bindgen_ty_5,
    pub delta: Dav1dFrameHeader__bindgen_ty_6,
    pub all_lossless: ::std::os::raw::c_int,
    pub loopfilter: Dav1dFrameHeader__bindgen_ty_7,
    pub cdef: Dav1dFrameHeader__bindgen_ty_8,
    pub restoration: Dav1dFrameHeader__bindgen_ty_9,
    pub txfm_mode: Dav1dTxfmMode,
    pub switchable_comp_refs: ::std::os::raw::c_int,
    pub skip_mode_allowed: ::std::os::raw::c_int,
    pub skip_mode_enabled: ::std::os::raw::c_int,
    pub skip_mode_refs: [::std::os::raw::c_int; 2usize],
    pub warp_motion: ::std::os::raw::c_int,
    pub reduced_txtp_set: ::std::os::raw::c_int,
    pub gmv: [Dav1dWarpedMotionParams; 7usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_1 {
    pub data: Dav1dFilmGrainData,
    pub present: ::std::os::raw::c_int,
    pub update: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_1>(),
        232usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_1),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_1),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_1),
            "::",
            stringify!(update)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint {
    pub buffer_removal_time: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_removal_time) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader_Dav1dFrameHeaderOperatingPoint),
            "::",
            stringify!(buffer_removal_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_2 {
    pub width_scale_denominator: ::std::os::raw::c_int,
    pub enabled: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width_scale_denominator) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_2),
            "::",
            stringify!(width_scale_denominator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_2),
            "::",
            stringify!(enabled)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_3 {
    pub uniform: ::std::os::raw::c_int,
    pub n_bytes: ::std::os::raw::c_uint,
    pub min_log2_cols: ::std::os::raw::c_int,
    pub max_log2_cols: ::std::os::raw::c_int,
    pub log2_cols: ::std::os::raw::c_int,
    pub cols: ::std::os::raw::c_int,
    pub min_log2_rows: ::std::os::raw::c_int,
    pub max_log2_rows: ::std::os::raw::c_int,
    pub log2_rows: ::std::os::raw::c_int,
    pub rows: ::std::os::raw::c_int,
    pub col_start_sb: [u16; 65usize],
    pub row_start_sb: [u16; 65usize],
    pub update: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_3() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_3> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_3>(),
        304usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uniform) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(uniform)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_bytes) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(n_bytes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_log2_cols) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(min_log2_cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_log2_cols) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(max_log2_cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_cols) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(log2_cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cols) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(cols)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min_log2_rows) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(min_log2_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_log2_rows) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(max_log2_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).log2_rows) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(log2_rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rows) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(rows)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).col_start_sb) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(col_start_sb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).row_start_sb) as usize - ptr as usize },
        170usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(row_start_sb)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_3),
            "::",
            stringify!(update)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_4 {
    pub yac: ::std::os::raw::c_int,
    pub ydc_delta: ::std::os::raw::c_int,
    pub udc_delta: ::std::os::raw::c_int,
    pub uac_delta: ::std::os::raw::c_int,
    pub vdc_delta: ::std::os::raw::c_int,
    pub vac_delta: ::std::os::raw::c_int,
    pub qm: ::std::os::raw::c_int,
    pub qm_y: ::std::os::raw::c_int,
    pub qm_u: ::std::os::raw::c_int,
    pub qm_v: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_4() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_4> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_4>(),
        40usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_4>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).yac) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(yac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ydc_delta) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(ydc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).udc_delta) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(udc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uac_delta) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(uac_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vdc_delta) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(vdc_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vac_delta) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(vac_delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(qm)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_y) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(qm_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_u) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(qm_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qm_v) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_4),
            "::",
            stringify!(qm_v)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_5 {
    pub enabled: ::std::os::raw::c_int,
    pub update_map: ::std::os::raw::c_int,
    pub temporal: ::std::os::raw::c_int,
    pub update_data: ::std::os::raw::c_int,
    pub seg_data: Dav1dSegmentationDataSet,
    pub lossless: [::std::os::raw::c_int; 8usize],
    pub qidx: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_5() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_5> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_5>(),
        344usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_5))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_5>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).enabled) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_map) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(update_map)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(temporal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).update_data) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(update_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seg_data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(seg_data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lossless) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(lossless)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).qidx) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_5),
            "::",
            stringify!(qidx)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_6 {
    pub q: Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1,
    pub lf: Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1 {
    pub present: ::std::os::raw::c_int,
    pub res_log2: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_log2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_1),
            "::",
            stringify!(res_log2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2 {
    pub present: ::std::os::raw::c_int,
    pub res_log2: ::std::os::raw::c_int,
    pub multi: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).present) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2),
            "::",
            stringify!(present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).res_log2) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2),
            "::",
            stringify!(res_log2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).multi) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6__bindgen_ty_2),
            "::",
            stringify!(multi)
        )
    );
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_6() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_6> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_6>(),
        20usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_6))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_6>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).q) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6),
            "::",
            stringify!(q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lf) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_6),
            "::",
            stringify!(lf)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_7 {
    pub level_y: [::std::os::raw::c_int; 2usize],
    pub level_u: ::std::os::raw::c_int,
    pub level_v: ::std::os::raw::c_int,
    pub mode_ref_delta_enabled: ::std::os::raw::c_int,
    pub mode_ref_delta_update: ::std::os::raw::c_int,
    pub mode_ref_deltas: Dav1dLoopfilterModeRefDeltas,
    pub sharpness: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_7() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_7> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_7>(),
        68usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_7))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_7>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_7))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_y) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(level_y)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_u) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(level_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).level_v) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(level_v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_ref_delta_enabled) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(mode_ref_delta_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_ref_delta_update) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(mode_ref_delta_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode_ref_deltas) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(mode_ref_deltas)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sharpness) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_7),
            "::",
            stringify!(sharpness)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_8 {
    pub damping: ::std::os::raw::c_int,
    pub n_bits: ::std::os::raw::c_int,
    pub y_strength: [::std::os::raw::c_int; 8usize],
    pub uv_strength: [::std::os::raw::c_int; 8usize],
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_8() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_8> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_8>(),
        72usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_8))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_8>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).damping) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_8),
            "::",
            stringify!(damping)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_bits) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_8),
            "::",
            stringify!(n_bits)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).y_strength) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_8),
            "::",
            stringify!(y_strength)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uv_strength) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_8),
            "::",
            stringify!(uv_strength)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dFrameHeader__bindgen_ty_9 {
    pub type_: [Dav1dRestorationType; 3usize],
    pub unit_size: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader__bindgen_ty_9() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader__bindgen_ty_9> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader__bindgen_ty_9>(),
        20usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader__bindgen_ty_9))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader__bindgen_ty_9>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader__bindgen_ty_9))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_9),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).unit_size) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader__bindgen_ty_9),
            "::",
            stringify!(unit_size)
        )
    );
}
#[test]
fn bindgen_test_layout_Dav1dFrameHeader() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dFrameHeader> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dFrameHeader>(),
        1680usize,
        concat!("Size of: ", stringify!(Dav1dFrameHeader))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dFrameHeader>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dFrameHeader))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).film_grain) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(film_grain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_type) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).width) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).height) as usize - ptr as usize },
        244usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_offset) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_offset)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).temporal_id) as usize - ptr as usize },
        252usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(temporal_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spatial_id) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(spatial_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_existing_frame) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(show_existing_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).existing_frame_idx) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(existing_frame_idx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_id) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_id)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_presentation_delay) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_presentation_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).show_frame) as usize - ptr as usize },
        276usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(show_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).showable_frame) as usize - ptr as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(showable_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).error_resilient_mode) as usize - ptr as usize },
        284usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(error_resilient_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).disable_cdf_update) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(disable_cdf_update)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_screen_content_tools) as usize - ptr as usize },
        292usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(allow_screen_content_tools)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).force_integer_mv) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(force_integer_mv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_size_override) as usize - ptr as usize },
        300usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_size_override)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).primary_ref_frame) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(primary_ref_frame)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).buffer_removal_time_present) as usize - ptr as usize },
        308usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(buffer_removal_time_present)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_points) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(operating_points)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh_frame_flags) as usize - ptr as usize },
        440usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(refresh_frame_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).render_width) as usize - ptr as usize },
        444usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(render_width)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).render_height) as usize - ptr as usize },
        448usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(render_height)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).super_res) as usize - ptr as usize },
        452usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(super_res)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).have_render_size) as usize - ptr as usize },
        460usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(have_render_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allow_intrabc) as usize - ptr as usize },
        464usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(allow_intrabc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_ref_short_signaling) as usize - ptr as usize },
        468usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(frame_ref_short_signaling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refidx) as usize - ptr as usize },
        472usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(refidx)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).hp) as usize - ptr as usize },
        500usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(hp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).subpel_filter_mode) as usize - ptr as usize },
        504usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(subpel_filter_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switchable_motion_mode) as usize - ptr as usize },
        508usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(switchable_motion_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).use_ref_frame_mvs) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(use_ref_frame_mvs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).refresh_context) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(refresh_context)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tiling) as usize - ptr as usize },
        520usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(tiling)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quant) as usize - ptr as usize },
        824usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(quant)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).segmentation) as usize - ptr as usize },
        864usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(segmentation)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).delta) as usize - ptr as usize },
        1208usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(delta)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_lossless) as usize - ptr as usize },
        1228usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(all_lossless)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).loopfilter) as usize - ptr as usize },
        1232usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(loopfilter)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cdef) as usize - ptr as usize },
        1300usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(cdef)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).restoration) as usize - ptr as usize },
        1372usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(restoration)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).txfm_mode) as usize - ptr as usize },
        1392usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(txfm_mode)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).switchable_comp_refs) as usize - ptr as usize },
        1396usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(switchable_comp_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_mode_allowed) as usize - ptr as usize },
        1400usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(skip_mode_allowed)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_mode_enabled) as usize - ptr as usize },
        1404usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(skip_mode_enabled)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).skip_mode_refs) as usize - ptr as usize },
        1408usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(skip_mode_refs)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).warp_motion) as usize - ptr as usize },
        1416usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(warp_motion)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reduced_txtp_set) as usize - ptr as usize },
        1420usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(reduced_txtp_set)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).gmv) as usize - ptr as usize },
        1424usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dFrameHeader),
            "::",
            stringify!(gmv)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dPictureParameters {
    #[doc = "< width (in pixels)"]
    pub w: ::std::os::raw::c_int,
    #[doc = "< height (in pixels)"]
    pub h: ::std::os::raw::c_int,
    #[doc = "< format of the picture"]
    pub layout: Dav1dPixelLayout,
    #[doc = "< bits per pixel component (8 or 10)"]
    pub bpc: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_Dav1dPictureParameters() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dPictureParameters> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dPictureParameters>(),
        16usize,
        concat!("Size of: ", stringify!(Dav1dPictureParameters))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dPictureParameters>(),
        4usize,
        concat!("Alignment of ", stringify!(Dav1dPictureParameters))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPictureParameters),
            "::",
            stringify!(w)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).h) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPictureParameters),
            "::",
            stringify!(h)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).layout) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPictureParameters),
            "::",
            stringify!(layout)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).bpc) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPictureParameters),
            "::",
            stringify!(bpc)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dPicture {
    pub seq_hdr: *mut Dav1dSequenceHeader,
    pub frame_hdr: *mut Dav1dFrameHeader,
    #[doc = " Pointers to planar image data (Y is [0], U is [1], V is [2]). The data\n should be bytes (for 8 bpc) or words (for 10 bpc). In case of words\n containing 10 bpc image data, the pixels should be located in the LSB\n bits, so that values range between [0, 1023]; the upper bits should be\n zero'ed out."]
    pub data: [*mut ::std::os::raw::c_void; 3usize],
    #[doc = " Number of bytes between 2 lines in data[] for luma [0] or chroma [1]."]
    pub stride: [isize; 2usize],
    pub p: Dav1dPictureParameters,
    pub m: Dav1dDataProps,
    #[doc = " High Dynamic Range Content Light Level metadata applying to this picture,\n as defined in section 5.8.3 and 6.7.3"]
    pub content_light: *mut Dav1dContentLightLevel,
    #[doc = " High Dynamic Range Mastering Display Color Volume metadata applying to\n this picture, as defined in section 5.8.4 and 6.7.4"]
    pub mastering_display: *mut Dav1dMasteringDisplay,
    #[doc = " Array of ITU-T T.35 metadata as defined in section 5.8.2 and 6.7.2"]
    pub itut_t35: *mut Dav1dITUTT35,
    #[doc = " Number of ITU-T T35 metadata entries in the array"]
    pub n_itut_t35: usize,
    #[doc = "< reserved for future use"]
    pub reserved: [usize; 3usize],
    #[doc = "< Dav1dFrameHeader allocation origin"]
    pub frame_hdr_ref: *mut Dav1dRef,
    #[doc = "< Dav1dSequenceHeader allocation origin"]
    pub seq_hdr_ref: *mut Dav1dRef,
    #[doc = "< Dav1dContentLightLevel allocation origin"]
    pub content_light_ref: *mut Dav1dRef,
    #[doc = "< Dav1dMasteringDisplay allocation origin"]
    pub mastering_display_ref: *mut Dav1dRef,
    #[doc = "< Dav1dITUTT35 allocation origin"]
    pub itut_t35_ref: *mut Dav1dRef,
    #[doc = "< reserved for future use"]
    pub reserved_ref: [usize; 4usize],
    #[doc = "< Frame data allocation origin"]
    pub ref_: *mut Dav1dRef,
    #[doc = "< pointer managed by the allocator"]
    pub allocator_data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_Dav1dPicture() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dPicture> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dPicture>(),
        264usize,
        concat!("Size of: ", stringify!(Dav1dPicture))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dPicture>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dPicture))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_hdr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(seq_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_hdr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(frame_hdr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).stride) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(stride)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).p) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(p)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(m)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_light) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(content_light)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mastering_display) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(mastering_display)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itut_t35) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(itut_t35)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_itut_t35) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(n_itut_t35)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_hdr_ref) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(frame_hdr_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).seq_hdr_ref) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(seq_hdr_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).content_light_ref) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(content_light_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mastering_display_ref) as usize - ptr as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(mastering_display_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).itut_t35_ref) as usize - ptr as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(itut_t35_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved_ref) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(reserved_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator_data) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicture),
            "::",
            stringify!(allocator_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dPicAllocator {
    #[doc = "< custom data to pass to the allocator callbacks."]
    pub cookie: *mut ::std::os::raw::c_void,
    #[doc = " Allocate the picture buffer based on the Dav1dPictureParameters.\n\n The data[0], data[1] and data[2] must be DAV1D_PICTURE_ALIGNMENT byte\n aligned and with a pixel width/height multiple of 128 pixels. Any\n allocated memory area should also be padded by DAV1D_PICTURE_ALIGNMENT\n bytes.\n data[1] and data[2] must share the same stride[1].\n\n This function will be called on the main thread (the thread which calls\n dav1d_get_picture()).\n\n @param  pic The picture to allocate the buffer for. The callback needs to\n             fill the picture data[0], data[1], data[2], stride[0] and\n             stride[1].\n             The allocator can fill the pic allocator_data pointer with\n             a custom pointer that will be passed to\n             release_picture_callback().\n @param cookie Custom pointer passed to all calls.\n\n @note No fields other than data, stride and allocator_data must be filled\n       by this callback.\n @return 0 on success. A negative DAV1D_ERR value on error."]
    pub alloc_picture_callback: ::std::option::Option<
        unsafe extern "C" fn(
            pic: *mut Dav1dPicture,
            cookie: *mut ::std::os::raw::c_void,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Release the picture buffer.\n\n If frame threading is used, this function may be called by the main\n thread (the thread which calls dav1d_get_picture()) or any of the frame\n threads and thus must be thread-safe. If frame threading is not used,\n this function will only be called on the main thread.\n\n @param pic    The picture that was filled by alloc_picture_callback().\n @param cookie Custom pointer passed to all calls."]
    pub release_picture_callback: ::std::option::Option<
        unsafe extern "C" fn(pic: *mut Dav1dPicture, cookie: *mut ::std::os::raw::c_void),
    >,
}
#[test]
fn bindgen_test_layout_Dav1dPicAllocator() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dPicAllocator> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dPicAllocator>(),
        24usize,
        concat!("Size of: ", stringify!(Dav1dPicAllocator))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dPicAllocator>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dPicAllocator))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicAllocator),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).alloc_picture_callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicAllocator),
            "::",
            stringify!(alloc_picture_callback)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).release_picture_callback) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dPicAllocator),
            "::",
            stringify!(release_picture_callback)
        )
    );
}
extern "C" {
    #[doc = " Release reference to a picture."]
    pub fn dav1d_picture_unref(p: *mut Dav1dPicture);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dData {
    #[doc = "< data pointer"]
    pub data: *const u8,
    #[doc = "< data size"]
    pub sz: usize,
    #[doc = "< allocation origin"]
    pub ref_: *mut Dav1dRef,
    #[doc = "< user provided metadata passed to the output picture"]
    pub m: Dav1dDataProps,
}
#[test]
fn bindgen_test_layout_Dav1dData() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dData>(),
        72usize,
        concat!("Size of: ", stringify!(Dav1dData))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dData>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dData),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sz) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dData),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ref_) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dData),
            "::",
            stringify!(ref_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dData),
            "::",
            stringify!(m)
        )
    );
}
extern "C" {
    #[doc = " Allocate data.\n\n @param data Input context.\n @param   sz Size of the data that should be allocated.\n\n @return Pointer to the allocated buffer on success. NULL on error."]
    pub fn dav1d_data_create(data: *mut Dav1dData, sz: usize) -> *mut u8;
}
extern "C" {
    #[doc = " Wrap an existing data array.\n\n @param          data Input context.\n @param           buf The data to be wrapped.\n @param            sz Size of the data.\n @param free_callback Function to be called when we release our last\n                      reference to this data. In this callback, $buf will be\n                      the $buf argument to this function, and $cookie will\n                      be the $cookie input argument to this function.\n @param        cookie Opaque parameter passed to free_callback().\n\n @return 0 on success. A negative DAV1D_ERR value on error."]
    pub fn dav1d_data_wrap(
        data: *mut Dav1dData,
        buf: *const u8,
        sz: usize,
        free_callback: ::std::option::Option<
            unsafe extern "C" fn(buf: *const u8, cookie: *mut ::std::os::raw::c_void),
        >,
        cookie: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Wrap a user-provided data pointer into a reference counted object.\n\n data->m.user_data field will initialized to wrap the provided $user_data\n pointer.\n\n $free_callback will be called on the same thread that released the last\n reference. If frame threading is used, make sure $free_callback is\n thread-safe.\n\n @param          data Input context.\n @param     user_data The user data to be wrapped.\n @param free_callback Function to be called when we release our last\n                      reference to this data. In this callback, $user_data\n                      will be the $user_data argument to this function, and\n                      $cookie will be the $cookie input argument to this\n                      function.\n @param        cookie Opaque parameter passed to $free_callback.\n\n @return 0 on success. A negative DAV1D_ERR value on error."]
    pub fn dav1d_data_wrap_user_data(
        data: *mut Dav1dData,
        user_data: *const u8,
        free_callback: ::std::option::Option<
            unsafe extern "C" fn(user_data: *const u8, cookie: *mut ::std::os::raw::c_void),
        >,
        cookie: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Free the data reference.\n\n The reference count for data->m.user_data will be decremented (if it has been\n initialized with dav1d_data_wrap_user_data). The $data object will be memset\n to 0.\n\n @param data Input context."]
    pub fn dav1d_data_unref(data: *mut Dav1dData);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dContext {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dLogger {
    #[doc = "< Custom data to pass to the callback."]
    pub cookie: *mut ::std::os::raw::c_void,
    #[doc = " Logger callback. May be NULL to disable logging.\n\n @param cookie Custom pointer passed to all calls.\n @param format The vprintf compatible format string.\n @param     ap List of arguments referenced by the format string."]
    pub callback: ::std::option::Option<
        unsafe extern "C" fn(
            cookie: *mut ::std::os::raw::c_void,
            format: *const ::std::os::raw::c_char,
            ap: va_list,
        ),
    >,
}
#[test]
fn bindgen_test_layout_Dav1dLogger() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dLogger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dLogger>(),
        16usize,
        concat!("Size of: ", stringify!(Dav1dLogger))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dLogger>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dLogger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cookie) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dLogger),
            "::",
            stringify!(cookie)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).callback) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dLogger),
            "::",
            stringify!(callback)
        )
    );
}
pub const Dav1dInloopFilterType_DAV1D_INLOOPFILTER_NONE: Dav1dInloopFilterType = 0;
pub const Dav1dInloopFilterType_DAV1D_INLOOPFILTER_DEBLOCK: Dav1dInloopFilterType = 1;
pub const Dav1dInloopFilterType_DAV1D_INLOOPFILTER_CDEF: Dav1dInloopFilterType = 2;
pub const Dav1dInloopFilterType_DAV1D_INLOOPFILTER_RESTORATION: Dav1dInloopFilterType = 4;
pub const Dav1dInloopFilterType_DAV1D_INLOOPFILTER_ALL: Dav1dInloopFilterType = 7;
pub type Dav1dInloopFilterType = ::std::os::raw::c_uint;
#[doc = "< decode and return all frames"]
pub const Dav1dDecodeFrameType_DAV1D_DECODEFRAMETYPE_ALL: Dav1dDecodeFrameType = 0;
#[doc = "< decode and return frames referenced by other frames only"]
pub const Dav1dDecodeFrameType_DAV1D_DECODEFRAMETYPE_REFERENCE: Dav1dDecodeFrameType = 1;
#[doc = "< decode and return intra frames only (includes keyframes)"]
pub const Dav1dDecodeFrameType_DAV1D_DECODEFRAMETYPE_INTRA: Dav1dDecodeFrameType = 2;
#[doc = "< decode and return keyframes only"]
pub const Dav1dDecodeFrameType_DAV1D_DECODEFRAMETYPE_KEY: Dav1dDecodeFrameType = 3;
pub type Dav1dDecodeFrameType = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dSettings {
    #[doc = "< number of threads (0 = number of logical cores in host system, default 0)"]
    pub n_threads: ::std::os::raw::c_int,
    #[doc = "< Set to 1 for low-latency decoding (0 = ceil(sqrt(n_threads)), default 0)"]
    pub max_frame_delay: ::std::os::raw::c_int,
    #[doc = "< whether to apply film grain on output frames (default 1)"]
    pub apply_grain: ::std::os::raw::c_int,
    #[doc = "< select an operating point for scalable AV1 bitstreams (0 - 31, default 0)"]
    pub operating_point: ::std::os::raw::c_int,
    #[doc = "< output all spatial layers of a scalable AV1 biststream (default 1)"]
    pub all_layers: ::std::os::raw::c_int,
    #[doc = "< maximum frame size, in pixels (0 = unlimited, default 0)"]
    pub frame_size_limit: ::std::os::raw::c_uint,
    #[doc = "< Picture allocator callback."]
    pub allocator: Dav1dPicAllocator,
    #[doc = "< Logger callback."]
    pub logger: Dav1dLogger,
    #[doc = "< whether to abort decoding on standard compliance violations\n< that don't affect actual bitstream decoding (e.g. inconsistent\n< or invalid metadata, default 0)"]
    pub strict_std_compliance: ::std::os::raw::c_int,
    #[doc = "< output invisibly coded frames (in coding order) in addition\n< to all visible frames. Because of show-existing-frame, this\n< means some frames may appear twice (once when coded,\n< once when shown, default 0)"]
    pub output_invisible_frames: ::std::os::raw::c_int,
    #[doc = "< postfilters to enable during decoding (default\n< DAV1D_INLOOPFILTER_ALL)"]
    pub inloop_filters: Dav1dInloopFilterType,
    #[doc = "< frame types to decode (default\n< DAV1D_DECODEFRAMETYPE_ALL)"]
    pub decode_frame_type: Dav1dDecodeFrameType,
    #[doc = "< reserved for future use"]
    pub reserved: [u8; 16usize],
}
#[test]
fn bindgen_test_layout_Dav1dSettings() {
    const UNINIT: ::std::mem::MaybeUninit<Dav1dSettings> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Dav1dSettings>(),
        96usize,
        concat!("Size of: ", stringify!(Dav1dSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<Dav1dSettings>(),
        8usize,
        concat!("Alignment of ", stringify!(Dav1dSettings))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).n_threads) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(n_threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max_frame_delay) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(max_frame_delay)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).apply_grain) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(apply_grain)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).operating_point) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(operating_point)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).all_layers) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(all_layers)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).frame_size_limit) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(frame_size_limit)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocator) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(allocator)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).logger) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(logger)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).strict_std_compliance) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(strict_std_compliance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).output_invisible_frames) as usize - ptr as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(output_invisible_frames)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).inloop_filters) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(inloop_filters)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).decode_frame_type) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(decode_frame_type)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Dav1dSettings),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " Get library version."]
    pub fn dav1d_version() -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Initialize settings to default values.\n\n @param s Input settings context."]
    pub fn dav1d_default_settings(s: *mut Dav1dSettings);
}
extern "C" {
    #[doc = " Allocate and open a decoder instance.\n\n @param c_out The decoder instance to open. *c_out will be set to the\n              allocated context.\n @param     s Input settings context.\n\n @note The context must be freed using dav1d_close() when decoding is\n       finished.\n\n @return 0 on success, or < 0 (a negative DAV1D_ERR code) on error."]
    pub fn dav1d_open(
        c_out: *mut *mut Dav1dContext,
        s: *const Dav1dSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Parse a Sequence Header OBU from bitstream data.\n\n @param out Output Sequence Header.\n @param buf The data to be parser.\n @param sz  Size of the data.\n\n @return\n                  0: Success, and out is filled with the parsed Sequence Header\n                     OBU parameters.\n  DAV1D_ERR(ENOENT): No Sequence Header OBUs were found in the buffer.\n  Other negative DAV1D_ERR codes: Invalid data in the buffer, invalid passed-in\n                                  arguments, and other errors during parsing.\n\n @note It is safe to feed this function data containing other OBUs than a\n       Sequence Header, as they will simply be ignored. If there is more than\n       one Sequence Header OBU present, only the last will be returned."]
    pub fn dav1d_parse_sequence_header(
        out: *mut Dav1dSequenceHeader,
        buf: *const u8,
        sz: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Feed bitstream data to the decoder, in the form of one or multiple AV1\n Open Bitstream Units (OBUs).\n\n @param   c Input decoder instance.\n @param  in Input bitstream data. On success, ownership of the reference is\n            passed to the library.\n\n @return\n         0: Success, and the data was consumed.\n  DAV1D_ERR(EAGAIN): The data can't be consumed. dav1d_get_picture() should\n                     be called to get one or more frames before the function\n                     can consume new data.\n  Other negative DAV1D_ERR codes: Error during decoding or because of invalid\n                                  passed-in arguments. The reference remains\n                                  owned by the caller."]
    pub fn dav1d_send_data(c: *mut Dav1dContext, in_: *mut Dav1dData) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Return a decoded picture.\n\n @param   c Input decoder instance.\n @param out Output frame. The caller assumes ownership of the returned\n            reference.\n\n @return\n         0: Success, and a frame is returned.\n  DAV1D_ERR(EAGAIN): Not enough data to output a frame. dav1d_send_data()\n                     should be called with new input.\n  Other negative DAV1D_ERR codes: Error during decoding or because of invalid\n                                  passed-in arguments.\n\n @note To drain buffered frames from the decoder (i.e. on end of stream),\n       call this function until it returns DAV1D_ERR(EAGAIN).\n\n @code{.c}\n  Dav1dData data = { 0 };\n  Dav1dPicture p = { 0 };\n  int res;\n\n  read_data(&data);\n  do {\n      res = dav1d_send_data(c, &data);\n      // Keep going even if the function can't consume the current data\n         packet. It eventually will after one or more frames have been\n         returned in this loop.\n      if (res < 0 && res != DAV1D_ERR(EAGAIN))\n          free_and_abort();\n      res = dav1d_get_picture(c, &p);\n      if (res < 0) {\n          if (res != DAV1D_ERR(EAGAIN))\n              free_and_abort();\n      } else\n          output_and_unref_picture(&p);\n  // Stay in the loop as long as there's data to consume.\n  } while (data.sz || read_data(&data) == SUCCESS);\n\n  // Handle EOS by draining all buffered frames.\n  do {\n      res = dav1d_get_picture(c, &p);\n      if (res < 0) {\n          if (res != DAV1D_ERR(EAGAIN))\n              free_and_abort();\n      } else\n          output_and_unref_picture(&p);\n  } while (res == 0);\n @endcode"]
    pub fn dav1d_get_picture(c: *mut Dav1dContext, out: *mut Dav1dPicture)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Apply film grain to a previously decoded picture. If the picture contains no\n film grain metadata, then this function merely returns a new reference.\n\n @param   c Input decoder instance.\n @param out Output frame. The caller assumes ownership of the returned\n            reference.\n @param  in Input frame. No ownership is transferred.\n\n @return\n         0: Success, and a frame is returned.\n  Other negative DAV1D_ERR codes: Error due to lack of memory or because of\n                                  invalid passed-in arguments.\n\n @note If `Dav1dSettings.apply_grain` is true, film grain was already applied\n       by `dav1d_get_picture`, and so calling this function leads to double\n       application of film grain. Users should only call this when needed."]
    pub fn dav1d_apply_grain(
        c: *mut Dav1dContext,
        out: *mut Dav1dPicture,
        in_: *const Dav1dPicture,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Close a decoder instance and free all associated memory.\n\n @param c_out The decoder instance to close. *c_out will be set to NULL."]
    pub fn dav1d_close(c_out: *mut *mut Dav1dContext);
}
extern "C" {
    #[doc = " Flush all delayed frames in decoder and clear internal decoder state,\n to be used when seeking.\n\n @param c Input decoder instance.\n\n @note Decoding will start only after a valid sequence header OBU is\n       delivered to dav1d_send_data().\n"]
    pub fn dav1d_flush(c: *mut Dav1dContext);
}
#[doc = " The last returned picture contains a reference to a new Sequence Header,\n either because it's the start of a new coded sequence, or the decoder was\n flushed before it was generated."]
pub const Dav1dEventFlags_DAV1D_EVENT_FLAG_NEW_SEQUENCE: Dav1dEventFlags = 1;
#[doc = " The last returned picture contains a reference to a Sequence Header with\n new operating parameters information for the current coded sequence."]
pub const Dav1dEventFlags_DAV1D_EVENT_FLAG_NEW_OP_PARAMS_INFO: Dav1dEventFlags = 2;
pub type Dav1dEventFlags = ::std::os::raw::c_uint;
extern "C" {
    #[doc = " Fetch a combination of DAV1D_EVENT_FLAG_* event flags generated by the decoding\n process.\n\n @param c Input decoder instance.\n @param flags Where to write the flags.\n\n @return 0 on success, or < 0 (a negative DAV1D_ERR code) on error.\n\n @note Calling this function will clear all the event flags currently stored in\n       the decoder.\n"]
    pub fn dav1d_get_event_flags(
        c: *mut Dav1dContext,
        flags: *mut Dav1dEventFlags,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the user-provided metadata associated with the input data packet\n for the last decoding error reported to the user, i.e. a negative return\n value (not EAGAIN) from dav1d_send_data() or dav1d_get_picture().\n\n @param   c Input decoder instance.\n @param out Output Dav1dDataProps. On success, the caller assumes ownership of\n            the returned reference.\n\n @return 0 on success, or < 0 (a negative DAV1D_ERR code) on error."]
    pub fn dav1d_get_decode_error_data_props(
        c: *mut Dav1dContext,
        out: *mut Dav1dDataProps,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the decoder delay, which is the number of internally buffered frames, not\n including reference frames.\n This value is guaranteed to be >= 1 and <= max_frame_delay.\n\n @param s Input settings context.\n\n @return Decoder frame delay on success, or < 0 (a negative DAV1D_ERR code) on\n         error.\n\n @note The returned delay is valid only for a Dav1dContext initialized with the\n       provided Dav1dSettings."]
    pub fn dav1d_get_frame_delay(s: *const Dav1dSettings) -> ::std::os::raw::c_int;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
#[doc = "< allocation origin"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dav1dRef {
    pub _address: u8,
}
